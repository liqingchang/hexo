---
title: 排序算法和最大公约数
tags:
  - 冒泡排序
  - 快速排序
  - 排序算法
  - 最大公约数
  - 直接插入排序
id: 138
categories:
  - Code
date: 2011-02-17 20:49:27
---

因为已经打算继续找程序员工作了（想想也没什么其他自己能找到的了....），工作的时候或者用不上，但是面试的时候不会还是比较囧的，所以最近看了下排序算法方面的东西。

正题之前先讲讲之前中兴遇到的一个简单的算法题吧，求最大公约数

方法十分简单，Gcd(a,b)=Gcd(b,a%b)

用程序描述这个等式就可以了

详细就是

public static int Gcd(int numA,int numB){   
&#160;&#160;&#160; if(numB==0)    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; return numA;    
&#160;&#160;&#160; else    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; return Gcd(numB,numA % numB);    
}    
就这么简单~但是面试的时候我不懂，因为不知道公式，只想到循环相除~

&#160;

好，转入正题

由于大家都知道我准备要走了，所以似乎都比较有默契的不再分配工作给我了，所以正好我可以好好看看自己要看的东西

首先是简单的冒泡排序

原理是每次排序都把最大（或者最小）的排到最底，然后重复上述直到排序完毕

public static int[] bubble(int[] array){   
&#160;&#160;&#160; int i,j,temp;    
&#160;&#160;&#160; for(i=0;i&lt;array.length-1;i++)    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; for(j=0;j&lt;array.length-i-1;j++)    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(array[j]&lt;array[j+1]){    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; temp=array[j+1];    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; array[j+1]=array[j];    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; array[j]=temp;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    
&#160;&#160;&#160; return array;    
}    

然后是直接插入排序

原理

1.第一个数作为已排序序列

2.第二个数和第一个数相比

3.第n个数和第n-1个数相比，如果小于第n-1个数，n和n-1交换之后分别和前面的数比较，直到找到一个数比他大

public static int[] Insert(int[] array){   
&#160;&#160;&#160; int i,j,temp;    
&#160;&#160;&#160; for(i=1;i&lt;array.length-1;i++)    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(array[i]&lt;array[i-1]){    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; temp=array[i-1];    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; array[i-1]=array[i];    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; array[i]=temp;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; j=i-1;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; while(j&gt;0){    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(array[j]&lt;array[j-1]){    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; temp=array[j-1];    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; array[j-1]=array[j];    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; array[j]=temp;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; j--;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    
&#160;&#160;&#160; return array;&#160;&#160;&#160; 
}    

最后是快速排序

分别设置前后2个指针，再设置一个基准数(key)，然后分别从前后往中间分别对比key

一趟排序的目的是key前面的数都比key小，key后面的数都比key大

然后递归调用快速排序函数处理key前面的一段序列和key后面的一段序列，直到排序完毕

public static int[] Quick(int[] array,int beg,int end){   
&#160;&#160;&#160;&#160;&#160;&#160;&#160; int left,right,temp;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; left = beg;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; right = end;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; do{    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; while(left&lt;right &amp;&amp; array[left]&lt;array[right])    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; right--;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(left&lt;right){    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; temp=array[left];    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; array[left]=array[right];    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; array[right]=temp;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; while(left&lt;right &amp;&amp; array[left]&lt;array[right])    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; left++;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(left&lt;right){    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; temp=array[left];    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; array[left]=array[right];    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; array[right]=temp;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; }while(left!=right);    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; left--;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; right++;    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(left&gt;beg)    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Quick(array,beg,left);    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(end&gt;right)    
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Quick(array,right,end);    
&#160;&#160;&#160;&#160;&#160;&#160;&#160; return array;    
&#160;&#160;&#160; }

快速排序大概就这样了~

还不是太熟练，数据结构的东西还需要努力

虽然我觉得对Java程序员来讲，设计模式方面的知识其实更重要的说

不过面试既然要考，就只好自己去学了，主动权在别人那

努力啊，废柴！